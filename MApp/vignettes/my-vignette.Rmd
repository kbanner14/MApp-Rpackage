---
title: "MApp: Model Averaged posteriors plot"
author: "Katharine Banner"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
  fig_capation: yes
vignette: >
  %\VignetteIndexEntry{MApp: Model Averaged posteriors plot}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r setup, echo = FALSE}
devtools::load_all("..")
```

```{r echo = TRUE}
library(MApp)
library(dplyr)
```

The `{MAPP}` packages provides a set of plotting functions to help researchers visually examine and scrutinize results from model averaging partial regression coefficinets. The plotting functions work with lists of posterior draws (`MApp()`), default output from the implementation of model averaging using the `OpenBUGS` or self programmed RJMCMC samplers @Citation software (`MApp_MCMC`), and with `bma` objects obtained from the `bms()` function (`MApp_bms()`). A quick introduction to Bayesian model averaging and details about the `bms()` function can be found in the `BMS` package vignette (`vignette("BMS")`). 

In brief, model averaging was developed as a predictive tool and its use has been recently extended to model averaging of partial regression coefficients across multiple models. The inference drawn from the latter application of model averaging typically results in explanations of "average effects" for each of the coefficients of interest. The main issue is that interpreting model averaged partial regression coefficients as "average effects" can be difficult to understand since their interpretations are not necessarily the same across models. `MApp` provides the user with a visual of how the model averaged posterior distributions are constructed. A detailed discussion of the rational behind the `MApp` plot can be found in _Model Averaging Partial Regression Coefficients: Considerations and Practical Guidelines_, @CITATION/PLACE TO FIND MANUSCRIPT. In this vignette we illustrate the utility of the plotting function as well as other useful functions in our package. 

## Using `MApp_bms()`

We will use the `brainData` in this package, which were obtained from the `case0902` dataset from the `Sleuth2` package. The data are comprised of average values for log gestation length log(days), litter size (number of offspring), log body size log(kg) and log brain weight log(g) for 96 species of mammals. 

```{r, brain, results='asis'}
data(brainData)
knitr::kable(head(brainData, 5))
```

We can use the `bms` function from the `BMS` package to obtain a `bma` object. 

```{r bmsobj}
library(BMS)
brain <- bms(brainData, g = "UIP", 
                    mprior = "uniform", 
                    user.int = F)
class(brain)
```

`bms` places Zellner's $g$-prior on the coefficients and we specify a discrete uniform prior on the  $2^3=$ `r 2^3` models in the model set, where the model set is defined by all first order combinations of the potential covariates (see `help(bms)` and `vignette("BMS")` for more details). To use `MApp_bms()` with an object generated by `bms()`, specify `x = bma-object`, and the format for the plotting window in vector form (e.g., `plot_wind = c(1,3)` will produce one row and three columns with one plot per column).

```{r bmsfig, fig.show = 'hold', fig.width = 7, fig.height = 5, fig.cap="MApp for each explanatory variable in the dataset"}
MApp_bms(x = brain, plot_wind = c(1,3))
```

__Add some takeaways__ 

We can add specific model names in place of the generic $M_1, M_2,..., M_7$ with the `mod_names` arguement. 

```{r bmsfig2, fig.show = 'hold', fig.width = 7, fig.height = 5, fig.cap="MApp for each explanatory variable in the dataset"}
MApp_bms(brain, plot_wind = c(1,3), 
          mod_names = c("BGL", "BG", "BL", "B", "G", "GL", "L", "Null"))

```


##Other options in `MApp_bms()`  

We will use the `bfat` data set, included in our package, to demonstrate the flexibility of our plotting function for problems with a larger set of potential predictors. These data were used in Hoeting et. al. (1999) to demonstrate some predictive advanatages of Bayesian model averaging. The goal was to predict percent body fat with the 13 predictors in the `bfat` data set. First, we will take a look at these data and create a `bma` object, `bfat_bms`, using the `bms()` function (again, we chose a uniform prior on the model space and Zellner's $g$-prior [citation] with $g = n$).

```{r, results='asis'}
data(bfat)
knitr::kable(head(bfat, 5))

# create bma object using bfat data
bfat_bms <- bms(bfat, mprior = "uniform", g = "UIP", user.int = F)
class(bfat_bms)
```

There are $2^{13} =$ `r 2^(13)` potential models in the model set. By default a `bma` object generated by `bms()` will store weights and posterior summary measures from the top 500 models. The user should check the proprotion of the posterior model mass that is accounted for by the top 500 models to ensure the approximation resulting from `MApp_bms` will be resonable. _Clean up this paragraph_. 

```{r}
# see how much of the posterior model mass is accounted for by the top 500
# models
sum(pmp.bma(bfat_bms)[,1])
```


Because plotting 500 models simulataneously would make the model averaged posteriors plot impossible to read, we can tell `MApp_bms()` to display a subset of those models using the `max_display` arguement.  We can also specify which coefficient to include in the model averaged posteriors plot with the `include_coef` argument. If `max_display` and `include_coef` are left unspecified, the function will plot all models and all coefficients. Because the object we are using in `MApp_bms` includes informaiton from the top 500 models, the posterior distribuiton for the model averaged partial regression coefficients will be gerenarted according to those top 500 models. __Make this cleaner...__ 


```{r bfatplot ,fig.width=7, fig.height=5, results='asis'}
bfat_mapp <- MApp_bms(bfat_bms, plot_wind = c(1,3), 
                        include_coef = c(13, 2, 4), 
                        max_display = 10, 
                        num_sims = 1000)

knitr::kable(bfat_mapp)
```

## Example 3  Using MApp() 

You may have wanted more flexibility in your model set, so you may have used `BUGS`, `OpenBUGS`, or programmed your own Gibbs sampler to search through the model space. In this case you will have many sets of posterior draws for the partial regression coefficients estimated by each of the models in your model set. Oftentimes this will be conveniently stored in a list of length equal to the cardinality of your model set. In this case, you can still create a Model Averaged posteriors plot using our function, you will just have to add a few more arguments. 

___[ADD EXAMPLE HERE!]___
